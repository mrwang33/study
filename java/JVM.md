**JVM学习**

- 内存模型![内存模型](https://i.loli.net/2018/07/23/5b558d3b34e89.png){:height="200px" width="200px"}
- 运行时数据区![运行时数据区](https://i.loli.net/2018/07/23/5b558d4313bab.png){:height="200px" width="200px"}

- 程序计数器: 指向当前线程正在执行的字节码指令的地址和行号
每个线程都有一个属于自己的程序计数器

- 虚拟机栈 存储当前线程运行方法所需要的数据、指令和返回地址

- 将class文件转成汇编代码 javap -c -v xxxx.class > p.txt

- 本地方法栈: 带native的方法 使用c或者c++实现的 描述本地方法出栈入栈的过程 和虚拟机栈类似

- 方法区 类信息、常量(1.7)、静态变量 JIT(即时编译 just in time)

- 堆(heap) 详见内存模型

**java内存模型**

- 1.8之前 有 新生代 老年代 永久代(在方法区)

- 1.8之后 新生代 老年代 MetaSpace(不在堆里面 由运行内存分配，为了规避永久代内存的问题而设计,和ArrayList类似 它可以自动扩容)

- 新生代分为3块 伊甸区 s0区 s1区 比例为8：1：1(?)

- 什么样的对象需要被GC?

```
	1, 判断算法
		a.引用计数法
		b.可达性分析 (GC Root可达性分析)
			哪些可以称为GC Root
				- 虚拟机栈中的本地变量表引用的对象
				- 方法区中 类静态变量引用的对象 常量引用的对象
				- 本地方法栈中JNI引用的对象
		c.不可达是否一定回回收？
			- 重写finalize() 进行挽救(建议什么情况下都不要挽救)
			
	
```

**JVM垃圾回收算法**

- JVM参数说明

- -X表示非官方的，不保证每一个jvm都会去实现 -XX表示可能导致不稳定的

```
	-Xms (s:start起始大小
	-Xmx (x:max最大大小)
	-Xmn (n:new 新生代大小)
```

- Minor GC (新生代回收器) Major GC(老年代回收器) Full GC(前两者之和)

