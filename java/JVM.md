**JVM学习**

- 内存模型![内存模型](https://i.loli.net/2018/07/23/5b558d3b34e89.png){:height="200px" width="200px"}
- 运行时数据区![运行时数据区](https://i.loli.net/2018/07/23/5b558d4313bab.png){:height="200px" width="200px"}

- 程序计数器: 指向当前线程正在执行的字节码指令的地址和行号
每个线程都有一个属于自己的程序计数器

- 虚拟机栈 线程私有 用于存储局部变量表、操作数栈、动态连接、方法出口等信息
```
	局部变量表： 存放了编译器可知的各种基本数据类型、对象引用
```

- 将class文件转成汇编代码 javap -c -v xxxx.class > p.txt

- 本地方法栈: 带native的方法 使用c或者c++实现的 描述本地方法出栈入栈的过程 和虚拟机栈类似

- 方法区 存放类信息、常量(1.7)、静态变量 JIT(即时编译 just in time)
```
	运行时常量池 属于方法区的一块
```

- 堆(heap) 详见内存模型
```
	存放对象实例 几乎所有的对象实例都在这里分配内存
```
-------------

- 常见异常

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。


-------------

**java内存模型**

- 1.8之前 有 新生代 老年代 永久代(在方法区)

- 1.8之后 新生代 老年代 MetaSpace(不在堆里面 由运行内存分配，为了规避永久代内存的问题而设计,和ArrayList类似 它可以自动扩容)

- 新生代分为3块 伊甸区 s0区 s1区 比例为8：1：1(?)

- 什么样的对象需要被GC?

```
	1, 判断算法
		a.引用计数法
			- 缺点：对象之间的循环引用可能导致它们的引用计数永远不为1
		b.可达性分析 (GC Root可达性分析)
			哪些可以称为GC Root
				- 虚拟机栈中的本地变量表引用的对象
				- 方法区中 类静态变量引用的对象 常量引用的对象
				- 本地方法栈中JNI(即一般说的Native方法)引用的对象
		c.不可达是否一定回回收？
			- 重写finalize() 进行挽救(建议什么情况下都不要挽救)
			
	
```

- 本地变量表的reference如何访问堆中的具体示例? 1,通过句柄访问reference存储句柄的地址 句柄里有实例数据的指定和到对象类型数据的指针 这种方式在对象被移动时只会改变句柄中的实例数据指针,而reference本身不需要修改。2,直接指针访问 reference中存储的直接就是对象地址这种方式好处在于很快。坏处在于需要频繁修改。

------------------

**JVM垃圾回收算法**

- JVM参数说明

- -X表示非官方的，不保证每一个jvm都会去实现 -XX表示可能导致不稳定的

```
	-Xms (s:start起始大小
	-Xmx (x:max最大大小)
	-Xmn (n:new 新生代大小)
```

- Minor GC (新生代回收) Major GC(老年代回收) Full GC(前两者之和)

- 回收算法

```
标记-清除算法

复制回收算法
	98%的对象都是朝生夕死的 所以新生代中分为Eden区和两个survivor区 每次进行Gc时都将Eden区和一个survivor区未能回收的对象复制到另一个没有用过的survivor区中，当这个survivor区的大小不够时则复制到老年代
标记-整理算法 
	老年代中对象通常可以存活很久 所以不能使用复制回收算法 使用这种类似标记清除的算法
```

- 什么样的对象会进入老年代

```
	1,占用内存稍大的对象    例如很长的字符串和数组 这类对象由于太大无法直接在Eden区分配内存 所以直接分配在老年代上 在开发中因尽量避免使用此类对象 影响性能
	2,根据对象的age判断 对象在Eden区中每熬过一次Minor GC它的age就会加1 当超过15次(默认值 可通过-XX:MaxTenuringThreshold设置)时就会被复制到老年代上
```

- JVM常用参数表
![JVM常用参数](https://i.loli.net/2018/07/30/5b5e693a9c05e.png)
![JVM常用参数](https://i.loli.net/2018/07/30/5b5e693a20ec5.png)


-----------

**虚拟机类加载机制**
- 类的生命周期
![TIM截图20180730112814.png](https://i.loli.net/2018/07/30/5b5e85dd4c7b7.png)


-----------------------------------

**JVM类加载**

- 三种类加载器
```
	1, 启动类加载器 由c/c++代码编写 负责加载lib下的类
	2，扩展类加载器 由java代码编写 负责加载ext目录下的类
	3，应用程序类加载器 这个就是程序中默认的类加载器
```

- 类加载器之间的关系

![类加载器](https://i.loli.net/2018/08/06/5b68195227ff1.png)

- 双亲委派模型

```
	当一个类收到加载类的请求时，不会立即去加载这个类，而是将这个类交给它的父加载器加载。每个类加载器都是如此，这就意味着所有的加载类的请求都会到达启动类加载器进行加载。当启动类加载器无法完成类加载时，才有它本身加载。这样做的好处时程序中不会存在两个java.lang.Object类。
```